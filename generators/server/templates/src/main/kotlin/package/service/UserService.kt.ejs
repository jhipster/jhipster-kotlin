<%#
 Copyright 2013-2020 the original author or authors from the JHipster project.

 This file is part of the JHipster project, see https://www.jhipster.tech/
 for more information.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-%>
package <%= packageName %>.service

import <%= packageName %>.config.ANONYMOUS_USER
import <%= packageName %>.config.DEFAULT_LANGUAGE
import <%= packageName %>.config.SYSTEM_ACCOUNT
<%_ if (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'neo4j' || databaseType === 'couchbase') { _%>
import <%= packageName %>.domain.Authority
<%_ } _%>
<%_ if (databaseType !== 'no') { _%>
import <%= packageName %>.domain.<%= asEntity('User') %>
    <%_ if (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'neo4j' || databaseType === 'couchbase') { _%>
import <%= packageName %>.repository.AuthorityRepository
        <%_ if (authenticationType === 'session' && !reactive) { _%>
import <%= packageName %>.repository.PersistentTokenRepository
        <%_ } _%>
    <%_ } _%>
import <%= packageName %>.repository.UserRepository
    <%_ if (searchEngine === 'elasticsearch') { _%>
import <%= packageName %>.repository.search.UserSearchRepository
    <%_ } _%>
    <%_ if (authenticationType !== 'oauth2') { _%>
import <%= packageName %>.security.USER
    <%_ } _%>
import <%= packageName %>.security.getCurrentUserLogin
<%_ } _%>
import <%= packageName %>.service.dto.<%= asDto('User') %>
<%_ if (authenticationType !== 'oauth2') { _%>
import tech.jhipster.security.RandomUtil
<%_ } _%>

<%_ if (databaseType !== 'no') { _%>
import org.slf4j.LoggerFactory
<%_ } _%>
<%_ if (cacheManagerIsAvailable === true) { _%>
import org.springframework.cache.CacheManager
<%_ } _%>
<%_ if (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'neo4j' || databaseType === 'couchbase') { _%>
    <%_ if (!reactive) { _%>
import org.springframework.data.domain.Page
    <%_ } _%>
import org.springframework.data.domain.Pageable
    <%_ if (authenticationType !== 'oauth2') { _%>
import org.springframework.scheduling.annotation.Scheduled
    <%_ } _%>
<%_ } _%>
<%_ if (authenticationType === 'oauth2') { _%>
import org.springframework.security.authentication.AbstractAuthenticationToken
import org.springframework.security.core.GrantedAuthority
import org.springframework.security.oauth2.client.authentication.OAuth2AuthenticationToken
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationToken
<%_ } _%>
<%_ if (authenticationType !== 'oauth2') { _%>
import org.springframework.security.crypto.password.PasswordEncoder
<%_ } _%>
import org.springframework.stereotype.Service
<%_ if (databaseType === 'sql') { _%>
import org.springframework.transaction.annotation.Transactional
<%_ } _%>
<%_ if (reactive) { _%>
import reactor.core.publisher.Flux
import reactor.core.publisher.Mono
import reactor.core.scheduler.Schedulers
<%_ } _%>

<%_ if ((databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'neo4j' || databaseType === 'couchbase') && authenticationType === 'session' && !reactive) { _%>
import java.time.LocalDate
<%_ } _%>
<%_ if (databaseType !== 'no') { _%>
import java.time.Instant
<%_ } _%>
<%_ if (databaseType === 'sql' && reactive && authenticationType !== 'oauth2') { _%>
import java.time.LocalDateTime
import java.time.ZoneOffset
<%_ } _%>
<%_ if (authenticationType !== 'oauth2' && (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'neo4j' || databaseType === 'couchbase')) { _%>
import java.time.temporal.ChronoUnit
<%_ } _%>
<%_ if (authenticationType === 'oauth2') { _%>
import java.util.Date
<%_ } _%>
import java.util.Optional
<%_ if (databaseType === 'cassandra') { _%>
import java.util.UUID
<%_ } _%>

/**
 * Service class for managing users.
 */
@Service
<%_ if (databaseType === 'sql' && !reactive) { _%>
@Transactional
<%_ } _%>
class UserService<% if (databaseType !== 'no') { %>(
    private val userRepository: UserRepository<%_ if (authenticationType !== 'oauth2') { _%>,
    private val passwordEncoder: PasswordEncoder<%_ } if (searchEngine === 'elasticsearch') { _%>,
    private val userSearchRepository: UserSearchRepository<%_ } if (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'neo4j' || databaseType === 'couchbase') { if (authenticationType === 'session' && !reactive) { _%>,
    private val persistentTokenRepository: PersistentTokenRepository<%_ } _%>,
    private val authorityRepository: AuthorityRepository<%_ } if (cacheManagerIsAvailable === true) { _%>,
    private val cacheManager: CacheManager
    <%_ } _%>
)<%_ } %> {
<%_ if (databaseType !== 'no') { _%>

    private val log = LoggerFactory.getLogger(javaClass)
<%_ if (authenticationType !== 'oauth2') { _%>

    <%_ if (databaseType === 'sql' && reactive) { _%>
    @Transactional
    <%_ } _%>
    fun activateRegistration(key: String): <% if (reactive) { %>Mono<% } else { %>Optional<% } %><<%= asEntity('User') %>> {
        log.debug("Activating user for activation key $key")
        return userRepository.findOneByActivationKey(key)
            .<% if (reactive) { %>flatMap<% } else { %>map<% } %> { user ->
                // activate given user for the registration key.
                user.activated = true
                user.activationKey = null
            <%_ if (!reactive) { _%>
                <%_ if (['mongodb', 'neo4j', 'couchbase', 'cassandra'].includes(databaseType)) { _%>
                userRepository.save(user)
                <%_ } _%>
                <%_ if (searchEngine === 'elasticsearch') { _%>
                userSearchRepository.save(user)
                <%_ } _%>
                <%_ if (cacheManagerIsAvailable === true) { _%>
                clearUserCaches(user)
                <%_ } _%>
                log.debug("Activated user: $user")
                user
            }
            <%_ } else { _%>
                saveUser(user)
            }
                <%_ if (searchEngine === 'elasticsearch') { _%>
            .flatMap { userSearchRepository.save(it).thenReturn(it) }
                <%_ } _%>
                <%_ if (cacheManagerIsAvailable === true) { _%>
            .doOnNext(this::clearUserCaches)
                <%_ } _%>
            .doOnNext { user -> log.debug("Activated user: $user") }
            <%_ } _%>
    }

    <%_ if (databaseType === 'sql' && reactive) { _%>
    @Transactional
    <%_ } _%>
    fun completePasswordReset(newPassword: String, key: String): <% if (reactive) { %>Mono<% } else { %>Optional<% } %><<%= asEntity('User') %>> {
        log.debug("Reset user password for reset key $key")
        return userRepository.findOneByResetKey(key)
            .filter { user -> user.resetDate?.isAfter(Instant.now().minusSeconds(86400)) ?: false }
            <%_ if (!reactive) { _%>
            .map {
                it.password = passwordEncoder.encode(newPassword)
                it.resetKey = null
                it.resetDate = null
                <%_ if (['mongodb', 'neo4j', 'couchbase', 'cassandra'].includes(databaseType)) { _%>
                userRepository.save(it)
                <%_ } _%>
                <%_ if (cacheManagerIsAvailable === true) { _%>
                clearUserCaches(it)
                <%_ } _%>
                it
            }
            <%_ } else { _%>
            .publishOn(Schedulers.boundedElastic())
            .map {
                it.password = passwordEncoder.encode(newPassword)
                it.resetKey = null
                it.resetDate = null
                it
            }
            .flatMap(this::saveUser)<% if (cacheManagerIsAvailable === true) { %>
            .doOnNext(this::clearUserCaches)<% } %>
            <%_ } _%>
    }

    <%_ if (databaseType === 'sql' && reactive) { _%>
    @Transactional
    <%_ } _%>
    fun requestPasswordReset(mail: String): <% if (reactive) { %>Mono<% } else { %>Optional<% } %><<%= asEntity('User') %>> {
        return userRepository.findOneByEmailIgnoreCase(mail)
            <%_ if (!reactive) { _%>
            .filter(<%= asEntity('User') %>::activated)
            .map {
                it.resetKey = RandomUtil.generateResetKey()
                it.resetDate = Instant.now()
                <%_ if (['mongodb', 'neo4j', 'couchbase', 'cassandra'].includes(databaseType)) { _%>
                userRepository.save(it)
                <%_ } _%>
                <%_ if (cacheManagerIsAvailable === true) { _%>
                clearUserCaches(it)
                <%_ } _%>
                it
            }
            <%_ } else { _%>
            .publishOn(Schedulers.boundedElastic())
            .map { 
                it.resetKey = RandomUtil.generateResetKey()
                it.resetDate = Instant.now()
                it
            }
            .flatMap(this::saveUser)<% if (cacheManagerIsAvailable === true) { %>
            .doOnNext(this::clearUserCaches)<% } %>
            <%_ } _%>
    }

    <%_ if (databaseType === 'sql' && reactive) { _%>
    @Transactional
    <%_ } _%>   
    fun registerUser(userDTO: <%= asDto('User') %>, password: String): <% if (reactive) { %>Mono<<%= asEntity('User') %>><% } else { %><%= asEntity('User') %><% } %> {
        val login = userDTO.login ?: throw IllegalArgumentException("Empty login not allowed")
        val email = userDTO.email
    <%_ if (!reactive) { _%>
        userRepository.findOneByLogin(login.toLowerCase()).ifPresent { existingUser ->
            val removed = removeNonActivatedUser(existingUser)
            if (!removed) {
                throw UsernameAlreadyUsedException()
            }
        }
        userRepository.findOneByEmailIgnoreCase(email).ifPresent { existingUser ->
            val removed = removeNonActivatedUser(existingUser)
            if (!removed) {
                throw EmailAlreadyUsedException()
            }
        }
        val newUser = <%= asEntity('User') %>()
        <%_ if (databaseType === 'cassandra') { _%>
        newUser.id = UUID.randomUUID().toString()
        <%_ } _%>
        val encryptedPassword = passwordEncoder.encode(password)
        newUser.apply {
            this.login = login.toLowerCase()
            // new user gets initially a generated password
            this.password = encryptedPassword
            firstName = userDTO.firstName
            lastName = userDTO.lastName
            this.email = email?.toLowerCase()
            <%_ if (['sql', 'mongodb', 'neo4j', 'couchbase'].includes(databaseType)) { _%>
            imageUrl = userDTO.imageUrl
            <%_ } _%>
            langKey = userDTO.langKey
            // new user is not active
            activated = false
            // new user gets registration key
            activationKey = RandomUtil.generateActivationKey()
            <%_ if (['sql', 'mongodb', 'neo4j'].includes(databaseType)) { _%>
            authorities = mutableSetOf()
            authorityRepository.findById(USER).ifPresent { authorities.add(it) }
            <%_ } else { _%>
            authorities = mutableSetOf(USER)
            <%_ } _%>
        }
        userRepository.save(newUser)
        <%_ if (searchEngine === 'elasticsearch') { _%>
        userSearchRepository.save(newUser)
        <%_ } _%>
        <%_ if (cacheManagerIsAvailable === true) { _%>
        clearUserCaches(newUser)
        <%_ } _%>
        log.debug("Created Information for User: $newUser")
        return newUser
    <%_ } else {// reactive _%>
        return userRepository.findOneByLogin(login.toLowerCase())
            .flatMap { existingUser ->
                if (!existingUser.activated) {
                    <%_ if (cacheManagerIsAvailable === true) { _%>
                    clearUserCaches(existingUser)
                    <%_ } _%>
                    userRepository.delete(existingUser)
                } else {
                    throw UsernameAlreadyUsedException()
                }
            }
            .then(userRepository.findOneByEmailIgnoreCase(email!!))
            .flatMap { existingUser ->
                if (!existingUser.activated) {
                    <%_ if (cacheManagerIsAvailable === true) { _%>
                    clearUserCaches(existingUser)
                    <%_ } _%>
                    userRepository.delete(existingUser)
                } else {
                    throw EmailAlreadyUsedException()
                }
            }
            .publishOn(Schedulers.boundedElastic())
            .then(Mono.fromCallable {
                <%= asEntity('User') %>().apply {
                    <%_ if (databaseType === 'cassandra') { _%>
                    id  = UUID.randomUUID().toString()
                    <%_ } _%>
                    val encryptedPassword = passwordEncoder.encode(password)
                    this.login = login.toLowerCase()
                    // new user gets initially a generated password
                    this.password = encryptedPassword
                    firstName = userDTO.firstName
                    lastName = userDTO.lastName
                    this.email = email?.toLowerCase()
                    <%_ if (['sql', 'mongodb', 'neo4j', 'couchbase'].includes(databaseType)) { _%>
                    imageUrl = userDTO.imageUrl
                    <%_ } _%>
                    langKey = userDTO.langKey
                    // new user is not active
                    activated = false
                    // new user gets registration key
                    activationKey = RandomUtil.generateActivationKey()
                }
            })
            .flatMap { newUser ->
                val authorities = mutableSetOf<<% if (['sql', 'mongodb', 'neo4j'].includes(databaseType)) { %>Authority<% } else { %>String<% } %>>()
                <%_ if (['sql', 'mongodb', 'neo4j'].includes(databaseType)) { _%>
                authorityRepository.findById(USER)
                    .map(authorities::add)
                    .thenReturn(newUser)
                    .doOnNext { user -> user.authorities = authorities }
                    .flatMap { saveUser(it) }
                <%_ } else { _%>
                authorities.add(USER)
                newUser.authorities = authorities
                saveUser(newUser)
                <%_ } _%>
                <%_ if (searchEngine === 'elasticsearch') { _%>
                    .flatMap { user -> userSearchRepository.save(user).thenReturn(user) }
                <%_ } _%>
                <%_ if (cacheManagerIsAvailable === true) { _%>
                    .doOnNext(this::clearUserCaches)
                <%_ } _%>
                    .doOnNext { user -> log.debug("Created Information for User: $user") }
            }
    <%_ } _%>
    }

    <%_ if (!reactive) { _%>
    private fun removeNonActivatedUser(existingUser: <%= asEntity('User') %>): Boolean {
        if (existingUser.activated) {
            return false
        }
        userRepository.delete(existingUser)
        <%_ if (databaseType === 'sql') { _%>
        userRepository.flush()
        <%_ } _%>
        <%_ if (cacheManagerIsAvailable === true) { _%>
        clearUserCaches(existingUser)
        <%_ } _%>
        return true
    }

    <%_ } _%>
    <%_ if (databaseType === 'sql' && reactive) { _%>
    @Transactional
    <%_ } _%>
    fun createUser(userDTO: <%= asDto('User') %>): <% if (reactive) { %>Mono<<%= asEntity('User') %>><% } else { %><%= asEntity('User') %><% } %> {
        val user = <%= asEntity('User') %>(
            <%_ if (databaseType === 'cassandra') { _%>
            id = UUID.randomUUID().toString(),
            <%_ } _%>
            login = userDTO.login?.toLowerCase(),
            firstName = userDTO.firstName,
            lastName = userDTO.lastName,
            email = userDTO.email?.toLowerCase(),
            <%_ if (['sql', 'couchbase', 'mongodb', 'neo4j'].includes(databaseType)) { _%>
            imageUrl = userDTO.imageUrl,
            <%_ } _%>
            // default language
            langKey = userDTO.langKey ?: DEFAULT_LANGUAGE<% if (!reactive) { %>,
            password = passwordEncoder.encode(RandomUtil.generatePassword()),
            resetKey = RandomUtil.generateResetKey(),
            resetDate = Instant.now(),
            activated = true,
            <%_ if (['sql', 'mongodb', 'neo4j'].includes(databaseType)) { _%>
            authorities = userDTO.authorities?.let { authorities ->
                authorities.map { authorityRepository.findById(it) }
                        .filter { it.isPresent }
                        .mapTo(mutableSetOf()) { it.get() }
            } ?: mutableSetOf()
            <%_ } else { _%>
            authorities = userDTO.authorities?.toMutableSet() ?: mutableSetOf()
            <%_ } _%>
        )
        userRepository.save(user)
        <%_ if (searchEngine === 'elasticsearch') { _%>
        userSearchRepository.save(user)
        <%_ } _%>
        <%_ if (cacheManagerIsAvailable === true) { _%>
        clearUserCaches(user)
        <%_ } _%>
        log.debug("Created Information for User: $user")
        return user
    <%_ } else { _%>
        )
        <%_ if (['sql', 'mongodb', 'neo4j'].includes(databaseType)) { _%>
        return Flux.fromIterable(userDTO.authorities ?: mutableSetOf())
            .flatMap<Authority>(authorityRepository::findById)
            .doOnNext { authority -> user.authorities.add(authority) }
            .then(Mono.just(user))
        <%_ } else { _%>
        user.authorities = userDTO.authorities?.toMutableSet() ?: mutableSetOf()
        return Mono.just(user)
        <%_ } _%>
            .publishOn(Schedulers.boundedElastic())
            .map {
                val encryptedPassword = passwordEncoder.encode(RandomUtil.generatePassword())
                it.password = encryptedPassword
                it.resetKey = RandomUtil.generateResetKey()
                it.resetDate = Instant.now()
                it.activated = true
                it
            }
            .flatMap(this::saveUser)
            <%_ if (searchEngine === 'elasticsearch') { _%>
            .flatMap { userSearchRepository.save(it).thenReturn(it) }
            <%_ } _%>
            <%_ if (cacheManagerIsAvailable === true) { _%>
            .doOnNext(this::clearUserCaches)
            <%_ } _%>
            .doOnNext { user -> log.debug("Changed Information for User: $user") }
            <%_ } _%>
    }

    /**
     * Update all information for a specific user, and return the modified user.
     *
     * @param userDTO user to update.
     * @return updated user.
     */
    <%_ if (databaseType === 'sql' && reactive) { _%>
    @Transactional
    <%_ } _%>
    fun updateUser(userDTO: <%= asDto('User') %>): <% if (reactive) { %>Mono<% } else { %>Optional<% } %><<%= asDto('User') %>> {
        <%_ if (!reactive) { _%>
        return Optional.of(userRepository.findById(userDTO.id!!))
            .filter(Optional<<%= asEntity('User') %>>::isPresent)
            .map { it.get() }
            .map { user ->
        <%_ } else { _%>
        return userRepository.findById(userDTO.id!!)
            .<%_ if (['sql', 'mongodb'].includes(databaseType)) { _%>flatMap<% } else { %>map<% } %> { user ->
        <%_ } _%>
                <%_ if (databaseType === 'couchbase') { _%>
                if (user.login != userDTO.login) {
                    userRepository.deleteById(userDTO.id!!)
                }
                <%_ } _%>
                <%_ if (cacheManagerIsAvailable === true) { _%>
                clearUserCaches(user)
                <%_ } _%>
                user.apply {
                    login = userDTO.login!!.toLowerCase()
                    firstName = userDTO.firstName
                    lastName = userDTO.lastName
                    email = userDTO.email?.toLowerCase()
                    <%_ if (['sql', 'mongodb', 'neo4j', 'couchbase'].includes(databaseType)) { _%>
                    imageUrl = userDTO.imageUrl
                    <%_ } _%>
                    activated = userDTO.activated
                    langKey = userDTO.langKey
                }
                <%_ if (['sql', 'mongodb', 'neo4j'].includes(databaseType)) { _%>
                val managedAuthorities = user.authorities
                managedAuthorities.clear()
                <%_ } else { // Cassandra & Couchbase _%>
                user.authorities = userDTO.authorities?.toMutableSet() ?: mutableSetOf()
                <%_ } _%>
        <%_ if (!reactive) { _%>
                <%_ if (['sql', 'mongodb'].includes(databaseType)) { _%>
                userDTO.authorities?.apply {
                    this.asSequence()
                        .map { authorityRepository.findById(it) }
                        .filter { it.isPresent }
                        .mapTo(managedAuthorities) { it.get() }
                }
                <%_ } _%>
                <%_ if (['mongodb', 'neo4j', 'couchbase', 'cassandra'].includes(databaseType)) { _%>
                userRepository.save(user)
                <%_ } _%>
                <%_ if (searchEngine === 'elasticsearch') { _%>
                userSearchRepository.save(user)
                <%_ } _%>
                <%_ if (cacheManagerIsAvailable === true) { _%>
                clearUserCaches(user)
                <%_ } _%>
                log.debug("Changed Information for User: $user")
                user
            }
        <%_ } else { // reactive _%>
                <%_ if (['sql', 'mongodb'].includes(databaseType)) { _%>
                Flux.fromIterable(userDTO.authorities!!)
                    .flatMap(authorityRepository::findById)
                    .map(managedAuthorities::add)
                    .then(Mono.just(user))
                <%_ } else { _%>
                user
                <%_ } _%>
            }
            .flatMap(this::saveUser)
            <%_ if (searchEngine === 'elasticsearch') { _%>
            .flatMap { userSearchRepository.save(it).thenReturn(it) }
            <%_ } _%>
            <%_ if (cacheManagerIsAvailable === true) { _%>
            .doOnNext(this::clearUserCaches)
            <%_ } _%>
            .doOnNext { log.debug("Changed Information for User: $it") }
        <%_ } _%>
            .map { <%= asDto('User') %>(it) }
    }

    <%_ if (!reactive) { _%>
    fun deleteUser(login: String) {
        userRepository.findOneByLogin(login).ifPresent { user ->
            userRepository.delete(user)
            <%_ if (searchEngine === 'elasticsearch') { _%>
            userSearchRepository.delete(user)
            <%_ } _%>
            <%_ if (cacheManagerIsAvailable === true) { _%>
            clearUserCaches(user)
            <%_ } _%>
            log.debug("Deleted User: $user")
        }
    }
    <%_ } else { _%>
        <%_ if (databaseType === 'sql') { _%>
    @Transactional
        <%_ } _%>
    fun deleteUser(login: String): Mono<Void> {
        return userRepository.findOneByLogin(login)
            .flatMap { userRepository.delete(it).thenReturn(it) }
            <%_ if (searchEngine === 'elasticsearch') { _%>
            .flatMap { userSearchRepository.delete(it).thenReturn(it) }
            <%_ } _%>
            <%_ if (cacheManagerIsAvailable === true) { _%>
            .doOnNext(this::clearUserCaches)
            <%_ } _%>
            .doOnNext { log.debug("Changed Information for User: $it") }
            .then()
    }
    <%_ } _%>
<%_ } // authenticationType !== 'oauth2' _%>
    /**
     * Update basic information (first name, last name, email, language) for the current user.
     *
     * @param firstName first name of user.
     * @param lastName  last name of user.
     * @param email     email id of user.
     * @param langKey   language key.
     <%_ if (['sql', 'mongodb', 'couchbase', 'neo4j'].includes(databaseType)) { _%>
     * @param imageUrl  image URL of user.
     <%_ } _%>
     */
    <%_ if (databaseType === 'sql' && reactive) { _%>
    @Transactional
    <%_ } _%>
    fun updateUser(firstName: String?, lastName: String?, email: String?, langKey: String?<% if (['sql', 'mongodb', 'couchbase', 'neo4j'].includes(databaseType)) { %>, imageUrl: String?<% } %>) <% if (reactive) { %>: Mono<Void><% } %> {
        <% if (reactive) { %>return <% } %>getCurrentUserLogin()
            .flatMap(userRepository::findOneByLogin)
            .<% if (reactive) { %>flatMap<% } else { %>ifPresent<% } %>{

                it.firstName = firstName
                it.lastName = lastName
                it.email = email?.toLowerCase()
                it.langKey = langKey
                <%_ if (['sql', 'mongodb', 'couchbase', 'neo4j'].includes(databaseType)) { _%>
                it.imageUrl = imageUrl
                <%_ } _%>
            <%_ if (!reactive) { _%>
                <%_ if (['mongodb', 'neo4j', 'couchbase', 'cassandra'].includes(databaseType)) { _%>
                userRepository.save(it)
                <%_ } _%>
                <%_ if (searchEngine === 'elasticsearch') { _%>
                userSearchRepository.save(it)
                <%_ } _%>
                <%_ if (cacheManagerIsAvailable === true) { _%>
                clearUserCaches(it)
                <%_ } _%>
                log.debug("Changed Information for User: $it")
            }
            <%_ } else { _%>
                saveUser(it)
            }
                <%_ if (searchEngine === 'elasticsearch') { _%>
                .flatMap { userSearchRepository.save(it).thenReturn(it) }
                <%_ } _%>
                <%_ if (cacheManagerIsAvailable === true) { _%>
                .doOnNext(this::clearUserCaches)
                <%_ } _%>
                .doOnNext { log.debug("Changed Information for User: $it") }
                .then()
            <%_ } _%>
    }

    <%_ if (reactive) { _%>
        <%_ if (databaseType === 'sql' && authenticationType === 'oauth2') { _%>
       @Transactional
       fun saveUser(User user) = saveUser(user, false)
    
        <%_ } _%>
        <%_ if (databaseType === 'sql') { _%>
        @Transactional
        <%_ } _%>
        <% if (databaseType !== 'sql') { %>private <% } %> fun saveUser(user: <%= asEntity('User') %><% if (databaseType === 'sql' && authenticationType === 'oauth2') { %>, forceCreate: boolean<% } %>): Mono<<%= asEntity('User') %>> {
            <%_ if (databaseType === 'cassandra') { _%>
            return userRepository.save(user)
            <%_ } else { _%>
            return getCurrentUserLogin()
                .switchIfEmpty(Mono.just(SYSTEM_ACCOUNT))
                .flatMap{ login ->
                    if (user.createdBy == null) {
                        user.createdBy = login
                    }
                    user.lastModifiedBy = login
                <%_ if (databaseType === 'sql') { _%>
                    // Saving the relationship can be done in an entity callback
                    // once https://github.com/spring-projects/spring-data-r2dbc/issues/215 is done
                    <%_ if (authenticationType === 'oauth2') { _%>
                    val persistedUser = if (forceCreate) { userRepository.create(user) } else { userRepository.save(user) }
                    persistedUser
                    <%_ } else { _%>
                    userRepository.save(user)
                    <%_ } _%>
                    userRepository.save(user)
                        .flatMap { user ->
                            Flux.fromIterable(user.authorities)
                                .flatMap { user.id?.let { it1 -> it.name?.let { it2 -> userRepository.saveUserAuthority(it1, it2) } } }
                                .then(Mono.just(user))
                        }
                <%_ } else { _%>
                    userRepository.save(user)
                <%_ } _%>
                }
            <%_ } _%>
        }

<%_ } _%>
<%_ if (authenticationType !== 'oauth2') { _%>
    <%_ if (databaseType === 'sql') { _%>
    @Transactional
    <%_ } _%>
    fun changePassword(currentClearTextPassword: String, newPassword: String)<% if (reactive) { %>: Mono<Void><% } %> {
        <% if (reactive) { %>return <% } %>getCurrentUserLogin()
            .flatMap(userRepository::findOneByLogin)
            <%_ if (reactive) { _%>
                .publishOn(Schedulers.boundedElastic())
                .map { user -> 
            <%_ } else { _%>
                .ifPresent { user -> 
            <%_ } _%>
                    val currentEncryptedPassword = user.password
                    if (!passwordEncoder.matches(currentClearTextPassword, currentEncryptedPassword)) {
                        throw InvalidPasswordException()
                    }
                    val encryptedPassword = passwordEncoder.encode(newPassword)
                    user.password = encryptedPassword
            <%_ if (!reactive) { _%>
                <%_ if (['mongodb', 'neo4j', 'couchbase', 'cassandra'].includes(databaseType)) { _%>
                userRepository.save(user)
                <%_ } _%>
                <%_ if (cacheManagerIsAvailable === true) { _%>
                clearUserCaches(user)
                <%_ } _%>
                log.debug("Changed password for User: $user")
                user
            }
            <%_ } else { _%>
                user
            }.flatMap { saveUser(it) }
            <%_ if (cacheManagerIsAvailable === true) { _%>
            .doOnNext(this::clearUserCaches)
            <%_ } _%>
            .doOnNext { user -> log.debug("Changed password for User: $user") }
            .then()
            <%_ } _%>
    }
<%_ } _%>

    <%_ if (databaseType === 'sql') { _%>
    @Transactional(readOnly = true)
    <%_ } _%>
    <%_ if (['sql', 'mongodb', 'neo4j', 'couchbase'].includes(databaseType)) { _%>
    fun getAllManagedUsers(pageable: Pageable): <% if (reactive) { %>Flux<% } else { %>Page<% } %><<%= asDto('User') %>> =
        userRepository.findAllByLoginNot(pageable, ANONYMOUS_USER).map { <%= asDto('User') %>(it) }
        <%_ if (reactive) { _%>
    <%_ if (databaseType === 'sql') { _%>
    @Transactional(readOnly = true)
    <%_ } _%>
    fun countManagedUsers() = userRepository.countAllByLoginNot(ANONYMOUS_USER)
        <%_ } _%>
    <%_ } else { // Cassandra _%>
    fun getAllManagedUsers() =
        userRepository.findAll()
            .filter { ANONYMOUS_USER != it.login }
            .map { <%= asDto('User') %>(it) }
    <%_ } _%>

    <%_ if (databaseType === 'sql') { _%>
    @Transactional(readOnly = true)
    <%_ } _%>
    fun getUserWithAuthoritiesByLogin(login: String): <% if (reactive) { %>Mono<% } else { %>Optional<% } %><<%= asEntity('User') %>> =
        userRepository.<% if (databaseType === 'sql') { %>findOneWithAuthoritiesByLogin(login)<% } else { %>findOneByLogin(login)<% } %>

    <%_ if (authenticationType !== 'oauth2') { _%>
        <%_ if (databaseType === 'sql') { _%>
    @Transactional(readOnly = true)
        <%_ } _%>
    fun getUserWithAuthorities(): <% if (reactive) { %>Mono<% } else { %>Optional<% } %><<%= asEntity('User') %>> =
        getCurrentUserLogin().flatMap(userRepository::findOne<% if (databaseType === 'sql') { %>WithAuthorities<% } %>ByLogin)
    <%_ } _%>   
    <%_ if ((databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'neo4j' || databaseType === 'couchbase') && authenticationType === 'session' && !reactive) { _%>

    /**
     * Persistent Token are used for providing automatic authentication, they should be automatically deleted after
     * 30 days.
     *
     * This is scheduled to get fired everyday, at midnight.
     */
    @Scheduled(cron = "0 0 0 * * ?")
    fun removeOldPersistentTokens() {
        val now = LocalDate.now()
        persistentTokenRepository.findByTokenDateBefore(now.minusMonths(1)).forEach { token ->
            log.debug("Deleting token ${token.series}")<% if (databaseType === 'sql') { %>
            val user = token.user
            user?.persistentTokens?.remove(token)<% } %>
            persistentTokenRepository.delete(token)
        }
    }
    <%_ } _%>
    <%_ if (authenticationType !== 'oauth2' && (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'neo4j' || databaseType === 'couchbase')) { _%>

    /**
     * Not activated users should be automatically deleted after 3 days.
     *
     * This is scheduled to get fired everyday, at 01:00 (am).
     */
    @Scheduled(cron = "0 0 1 * * ?")
    fun removeNotActivatedUsers() {
        <%_ if (!reactive) { _%>
        userRepository
            .findAllByActivatedIsFalseAndActivationKeyIsNotNullAndCreatedDateBefore(
                Instant.now().minus(3, ChronoUnit.DAYS)
            )
            .forEach { user ->
                log.debug("Deleting not activated user ${user.login}")
                userRepository.delete(user)
                <%_ if (searchEngine === 'elasticsearch') { _%>
                userSearchRepository.delete(user)
                <%_ } _%>
                <%_ if (cacheManagerIsAvailable === true) { _%>
                clearUserCaches(user)
                <%_ } _%>
            }
            <%_ } else { _%>
        removeNotActivatedUsersReactively().blockLast()
    }
    <%_ if (databaseType === 'sql') { _%>
    @Transactional
    <%_ } _%>
    fun removeNotActivatedUsersReactively(): Flux<User> {
        return userRepository
            .findAllByActivatedIsFalseAndActivationKeyIsNotNullAndCreatedDateBefore(<%_ if (databaseType === 'sql') { _%>LocalDateTime.ofInstant(Instant.now().minus(3, ChronoUnit.DAYS), ZoneOffset.UTC)<%_ } else { _%>Instant.now().minus(3, ChronoUnit.DAYS)<%_ } _%>)            
            .flatMap { user -> userRepository.delete(user).thenReturn(user) }
            <%_ if (searchEngine === 'elasticsearch') { _%>
            .flatMap { user -> userSearchRepository.delete(user).thenReturn(user) }
            <%_ } _%>
            <%_ if (cacheManagerIsAvailable === true) { _%>
            .doOnNext(this::clearUserCaches)
            <%_ } _%>
            .doOnNext { user -> log.debug("Deleted User: $user") }
            <%_ } _%>
    }
    <%_ } _%>
    <%_ if (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'neo4j' || databaseType === 'couchbase') { _%>

    /**
     * @return a list of all the authorities
     */
    <%_ if (databaseType === 'sql') { _%>
    @Transactional(readOnly = true)
    <%_ } _%>
    fun getAuthorities() =
        authorityRepository.findAll()<% if (!reactive) { %>.asSequence().map { it.name }.filterNotNullTo(mutableListOf())<% } else { %>.map(Authority::name)<% } %>
    <%_ } _%>
    <%_ if (authenticationType === 'oauth2') { _%>

    private fun syncUserWithIdP(details: Map<String, Any>, user: <%= asEntity('User') %>): <% if (reactive) { %>Mono<<%= asEntity('User') %>><% } else { %><%= asEntity('User') %><% } %> {
        // save authorities in to sync user roles/groups between IdP and JHipster's local database
        <%_ if (!reactive) { _%>
        val dbAuthorities = getAuthorities()
        <%_ if (databaseType !== 'couchbase') { _%>
        val userAuthorities = user.authorities.asSequence().mapTo(mutableListOf(), Authority::name)
        <%_ } else { _%>
        val userAuthorities = user.authorities
        <%_ } _%>
        for (authority in userAuthorities) {
            if (!dbAuthorities.contains(authority)) {
                log.debug("Saving authority '$authority' in local database")
                val authorityToSave = Authority(name = authority)
                authorityRepository.save(authorityToSave)
            }
        }
        // save account in to sync users between IdP and JHipster's local database
        val existingUser = userRepository.findOneByLogin(user.login!!)
        if (existingUser.isPresent) {
            // if IdP sends last updated information, use it to determine if an update should happen
            if (details["updated_at"] != null) {
                val dbModifiedDate = existingUser.get().lastModifiedDate
                val idpModifiedDate = details["updated_at"] as Instant
                if (idpModifiedDate.isAfter(dbModifiedDate)) {
                    log.debug("Updating user '${user.login}' in local database")
                    updateUser(user.firstName, user.lastName, user.email, user.langKey, user.imageUrl)
                }
                // no last updated info, blindly update
            } else {
                log.debug("Updating user '${user.login}' in local database")
                updateUser(user.firstName, user.lastName, user.email, user.langKey, user.imageUrl)
            }
        } else {
            log.debug("Saving user '${user.login}' in local database")
            userRepository.save(user)
            <%_ if (cacheManagerIsAvailable === true) { _%>
            clearUserCaches(user)
            <%_ } _%>
        }
        return user
        <%_ } else { _%>
        val userAuthorities =
            user.authorities<% if (databaseType !== 'couchbase') { %>.map { it.name }<% } %>.toList()

        return getAuthorities().collectList()
            .flatMapMany { dbAuthorities: List<String?> ->
                val authoritiesToSave = userAuthorities.filter { authority: String? -> !dbAuthorities.contains(authority) }
                    .map { authority: String? ->
                        val authorityToSave = Authority()
                        authorityToSave.name = authority
                        authorityToSave
                    }
                Flux.fromIterable(authoritiesToSave)
            }
            .doOnNext { authority: Authority? -> log.debug("Saving authority '$authority' in local database") }
            .flatMap<Authority> { authorityRepository.save(it) }
            .then(userRepository.findOneByLogin(user.login!!))
            .switchIfEmpty(<% if (authenticationType === 'oauth2' && databaseType === 'sql') { %>saveUser(user, true)<% } else { %>userRepository.save(user)<% } %>)
            .flatMap<Any> { existingUser: User ->
                // if IdP sends last updated information, use it to determine if an update should happen
                if (details["updated_at"] != null) {
                    val dbModifiedDate = existingUser.lastModifiedDate
                    val idpModifiedDate = details["updated_at"] as Instant
                    if (idpModifiedDate.isAfter(dbModifiedDate)) {
                        log.debug("Updating user '${user.login}' in local database")
                        return@flatMap updateUser(user.firstName, user.lastName, user.email, user.langKey, user.imageUrl)
                    }
                    // no last updated info, blindly update
                } else {
                    log.debug("Updating user '${user.login}' in local database")
                    return@flatMap updateUser(user.firstName, user.lastName, user.email, user.langKey, user.imageUrl)
                }
                return@flatMap Mono.empty<User>()
            }
            .thenReturn(user)
            <%_ } _%>
    }
    <%_ } _%>

<%_ } // databaseType !== 'no' _%>
    <%_ if (authenticationType === 'oauth2') { _%>
    /**
     * Returns the user from an OAuth 2.0 login or resource server with JWT.
        <%_ if (databaseType !== 'no') { _%>
     * Synchronizes the user in the local repository.
        <%_ } _%>
     *
     * @param authToken the authentication token.
     * @return the user from the authentication.
     */
        <%_ if (databaseType === 'sql') { _%>
    @Transactional
        <%_ } _%> 
    fun getUserFromAuthentication(authToken: AbstractAuthenticationToken): <% if (!reactive) { %>UserDTO<% } else { %>Mono<UserDTO><% } %> {
        val attributes: Map<String, Any> =
            when (authToken) {
                is OAuth2AuthenticationToken -> authToken.principal.attributes
                is JwtAuthenticationToken -> authToken.tokenAttributes
                else -> throw IllegalArgumentException("AuthenticationToken is not OAuth2 or JWT!")
            }

        val user = getUser(attributes)
        user.authorities = authToken.authorities.asSequence()
            .map(GrantedAuthority::getAuthority)
            <%_ if (['sql', 'mongodb', 'neo4j'].includes(databaseType)) { _%>
            .map { Authority(name = it) }
            <%_ } _%>
            .toMutableSet()
        return <% if (databaseType !== 'no' && !reactive) { %>UserDTO(syncUserWithIdP(attributes, user))<% } else if (!reactive) { %>user<% } %><% if (databaseType === 'no' && reactive) { %>Mono.just(user)<% } else if (reactive) { %>syncUserWithIdP(attributes, user).flatMap { Mono.just(UserDTO(it)) }<% } %>
    }
    <%_ } _%>
    <%_ if (cacheManagerIsAvailable === true && databaseType !== 'no') { _%>

    private fun clearUserCaches(user: <%= asEntity('User') %>) {
        cacheManager.getCache(UserRepository.USERS_BY_LOGIN_CACHE)?.evict(user.login!!)
        if(user.email != null) {
            cacheManager.getCache(UserRepository.USERS_BY_EMAIL_CACHE)?.evict(user.email)
        }
    }
    <%_ } _%>
    <%_ if (authenticationType === 'oauth2') { _%>

    companion object {

        @JvmStatic
        private fun getUser(details: Map<String, Any>): <%= databaseType === 'no' ? asDto('User') : asEntity('User') %> {
            val user = <%= databaseType === 'no' ? asDto('User') : asEntity('User') %>()
            // handle resource server JWT, where sub claim is email and uid is ID
            if (details["uid"] != null) {
                user.id = details["uid"] as String
                user.login = details["sub"] as String
            } else {
                user.id = details["sub"] as String
            }
            if (details["preferred_username"] != null) {
                user.login = (details["preferred_username"] as String).toLowerCase()
            } else if (user.login == null) {
                user.login = user.id
            }
            if (details["given_name"] != null) {
                user.firstName = details["given_name"] as String
            }
            if (details["family_name"] != null) {
                user.lastName = details["family_name"] as String
            }
            if (details["email_verified"] != null) {
                user.activated = details["email_verified"] as Boolean
            }
            if (details["email"] != null) {
                user.email = (details["email"] as String).toLowerCase()
            } else {
                user.email = details["sub"] as String
            }
            if (details["langKey"] != null) {
                user.langKey = details["langKey"] as String
            } else if (details["locale"] != null) {
                // trim off country code if it exists
                var locale = details["locale"] as String
                if (locale.contains("_")) {
                    locale = locale.substring(0, locale.indexOf("_"))
                } else if (locale.contains("-")) {
                    locale = locale.substring(0, locale.indexOf("-"))
                }
                user.langKey = locale.toLowerCase()
            } else {
                // set langKey to default if not specified by IdP
                user.langKey = DEFAULT_LANGUAGE
            }
            if (details["picture"] != null) {
                user.imageUrl = details["picture"] as String
            }
            user.activated = true
            return user
        }
    }
    <%_ } _%>
}
