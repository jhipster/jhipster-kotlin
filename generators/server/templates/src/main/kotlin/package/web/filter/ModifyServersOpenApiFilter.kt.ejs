package <%= packageName %>.web.filter

import com.fasterxml.jackson.core.JsonProcessingException
import com.fasterxml.jackson.databind.JsonNode
import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.databind.node.ArrayNode
import com.fasterxml.jackson.databind.node.ObjectNode
import java.io.ByteArrayInputStream
import java.io.ByteArrayOutputStream
import java.io.IOException
import java.nio.charset.StandardCharsets
import java.util.List
import java.util.Objects
import java.util.zip.GZIPInputStream
import java.util.zip.GZIPOutputStream
import org.reactivestreams.Publisher
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import org.springframework.cloud.gateway.filter.GatewayFilterChain
import org.springframework.cloud.gateway.filter.GlobalFilter
import org.springframework.core.Ordered
import org.springframework.core.io.buffer.DataBuffer
import org.springframework.core.io.buffer.DataBufferFactory
import org.springframework.core.io.buffer.DataBufferUtils
import org.springframework.core.io.buffer.DefaultDataBufferFactory
import org.springframework.http.HttpHeaders
import org.springframework.http.server.reactive.ServerHttpResponse
import org.springframework.http.server.reactive.ServerHttpResponseDecorator
import org.springframework.stereotype.Component
import org.springframework.web.server.ServerWebExchange
import reactor.core.publisher.Flux
import reactor.core.publisher.Mono

@Component
class ModifyServersOpenApiFilter: GlobalFilter, Ordered {

    private val log = LoggerFactory.getLogger(javaClass)

    override fun filter(exchange: ServerWebExchange, chain: GatewayFilterChain): Mono<Void> {
        val path = exchange.request.uri.path
        if (path.startsWith("/services") && path.contains("/v3/api-docs")) {
            val originalResponse = exchange.response
            val bufferFactory = originalResponse.bufferFactory()
            val decoratedResponse = createModifyServersOpenApiInterceptor(path, originalResponse, bufferFactory)

            // replace response with decorator
            return chain.filter(exchange.mutate().response(decoratedResponse).build())
        } else {
            return chain.filter(exchange)
        }
    }

    override fun getOrder() = -1

    fun createModifyServersOpenApiInterceptor(
        path: String,
        originalResponse: ServerHttpResponse,
        bufferFactory: DataBufferFactory
    ): ModifyServersOpenApiInterceptor {
        return ModifyServersOpenApiInterceptor(path, originalResponse, bufferFactory)
    }

    class ModifyServersOpenApiInterceptor(
        path: String, 
        originalResponse: ServerHttpResponse,
        bufferFactory: DataBufferFactory
    ): ServerHttpResponseDecorator(originalResponse) {

        fun getRewritedBody() = rewritedBody

        override fun <X: DataBuffer> writeWith(body: Publisher<X>): Mono<Void> {
            rewritedBody = ""
            if (body instanceof Flux) {
                val fluxBody = (Flux<X: DataBuffer>) body

                return super.writeWith(fluxBody.buffer().map(dataBuffers -> rewriteBodyWithServers(dataBuffers)))
            }
            // when body is not a flux
            return super.writeWith(body)
        }

        private fun <X: DataBuffer> rewriteBodyWithServers(dataBuffers: List<X>): DataBuffer {
            val dataBufferFactory = DefaultDataBufferFactory()
            val join = dataBufferFactory.join(dataBuffers)
            val content = ByteArray(join.readableByteCount())
            join.read(content)

            // release memory
            DataBufferUtils.release(join)
            val strBody = contentToString(content)

            try {
                // create custom server
                val mapper = ObjectMapper()
                val jsonBody = mapper.readTree(strBody)
                val serversToJson = mapper.createObjectNode()
                serversToJson.set("url", mapper.valueToTree(path.replace("/v3/api-docs", "")))
                serversToJson.set("description", mapper.valueToTree("added by global filter"))

                // add custom server
                val servers = mapper.createArrayNode()
                servers.add(serversToJson)
                (jsonBody as ObjectNode).set("servers", servers)

                rewritedBody = jsonBody.toString()
                return rewritedBodyToDataBuffer()
            } catch (e: JsonProcessingException) { 
                log.error("Error when modify servers from api-doc of {}: {}", path, e.getMessage())
            }
            return join
        }

        private fun rewritedBodyToDataBuffer(): DataBuffer {
            if (isZippedResponse()) {
                val zippedBody = zipContent(rewritedBody)
                originalResponse.headers.setContentLength(zippedBody.length)
                return bufferFactory.wrap(zippedBody)
            }
            originalResponse.headers.setContentLength(rewritedBody.getBytes().length)
            return bufferFactory.wrap(rewritedBody.getBytes())
        }

        private fun contentToString(content: byteArray): String {
            if (isZippedResponse()) {
                val unzippedContent = unzipContent(content)
                return String(unzippedContent, Charsets.UTF_8)
            }
            return String(content, Charsets.UTF_8)
        }

        private fun isZippedResponse() =
            !originalResponse.getHeaders().isEmpty() &&
                originalResponse.getHeaders().get(HttpHeaders.CONTENT_ENCODING) != null &&
                Objects.requireNonNull(originalResponse.getHeaders().get(HttpHeaders.CONTENT_ENCODING)).contains("gzip")

        private fun unzipContent(byte[] content): ByteArray {
            try {
                val gzipInputStream = GZIPInputStream(ByteArrayInputStream(content))
                val unzippedContent = gzipInputStream.readAllBytes()
                gzipInputStream.close()
                return unzippedContent
            } catch (e: IOException) {
                log.error("Error when unzip content during modify servers from api-doc of {}: {}", path, e.getMessage())
            }
            return content
        }

        private fun zipContent(content: String): ByteArray {
            try {
                ByteArrayOutputStream byteArrayOutputStream = ByteArrayOutputStream(content.length)
                GZIPOutputStream gzipOutputStream = GZIPOutputStream(byteArrayOutputStream)
                gzipOutputStream.write(content.encodeToByteArray())
                gzipOutputStream.flush()
                gzipOutputStream.close()
                return byteArrayOutputStream.toByteArray()
            } catch (IOException e) {
                log.error("Error when zip content during modify servers from api-doc of {}: {}", path, e.getMessage())
            }
            return content.encodeToByteArray()
        }
    }
}
