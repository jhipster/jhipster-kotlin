<%#
 Copyright 2013-2024 the original author or authors from the JHipster project.

 This file is part of the JHipster project, see https://www.jhipster.tech/
 for more information.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-%>
package <%= packageName %>.config

import static <%= packageName %>.security.SecurityUtils.AUTHORITIES_KEY
import static <%= packageName %>.security.SecurityUtils.JWT_ALGORITHM

import <%= packageName %>.management.SecurityMetersService
import com.nimbusds.jose.jwk.source.ImmutableSecret
import com.nimbusds.jose.util.Base64
import jakarta.crypto.SecretKey
import jakarta.crypto.spec.SecretKeySpec
import org.springframework.beans.factory.annotation.Value
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.security.oauth2.jwt.<%= reactive ? 'Reactive' : '' %>JwtDecoder
import org.springframework.security.oauth2.jwt.JwtEncoder
import org.springframework.security.oauth2.jwt.Nimbus<%= reactive ? 'Reactive' : '' %>JwtDecoder
import org.springframework.security.oauth2.jwt.NimbusJwtEncoder
import org.springframework.security.oauth2.server.resource.authentication.<%= reactive ? 'Reactive' : '' %>JwtAuthenticationConverter
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter
<%_ if (reactive) { _%>
import org.springframework.security.oauth2.server.resource.authentication.ReactiveJwtGrantedAuthoritiesConverterAdapter
<%_ } _%>
<%_ if (communicationSpringWebsocket) { %>
import org.springframework.security.oauth2.server.resource.web.BearerTokenResolver
import org.springframework.security.oauth2.server.resource.web.DefaultBearerTokenResolver
<%_ } _%>

@Configuration
class SecurityJwtConfiguration {

    @Value("\${jhipster.security.authentication.jwt.base64-secret}")
    private lateinit var jwtKey: String

    @Bean
    fun jwtDecoder(metersService: SecurityMetersService): <%= reactive ? 'Reactive' : '' %>JwtDecoder {
        val jwtDecoder = Nimbus<%= reactive ? 'Reactive' : '' %>JwtDecoder.withSecretKey(getSecretKey()).macAlgorithm(JWT_ALGORITHM).build()
        return <%= reactive ? 'Reactive' : '' %>JwtDecoder { token -> {
<%_ if (reactive) { %>
            try {
                jwtDecoder
                    .decode(token)
                    .doOnError { e ->
                        if (e.message!!.contains("Jwt Expired at")) {
                            metersService.trackTokenExpired()
                        } else if (e.message!!.contains("Failed to validate the token")) {
                            metersService.trackTokenInvalidSignature()
                        }
                    }
            } catch (e: Exception) {
                if (e.message!!.contains("An error occurred while attempting to decode the Jwt")) {
                    metersService.trackTokenMalformed()
                } else if (e.message!!.contains("Failed to validate the token")) {
                    metersService.trackTokenInvalidSignature()
                }
                throw e
            }
<%_ } else { _%>
            try {
                jwtDecoder.decode(token)
            } catch (e: Exception) {
                if (e.message!!.contains("Invalid signature")) {
                    metersService.trackTokenInvalidSignature()
                } else if (e.message!!.contains("Jwt expired at")) {
                    metersService.trackTokenExpired()
                } else if (e.message!!.contains("Invalid JWT serialization")) {
                    metersService.trackTokenMalformed()
                } else if (e.message!!.contains("Invalid unsecured/JWS/JWE")) {
                    metersService.trackTokenMalformed()
                }
                throw e
            }
<%_ } _%>
        }
    }
}

    @Bean
    fun jwtEncoder() = NimbusJwtEncoder(ImmutableSecret<>(getSecretKey()))

    @Bean
    fun jwtAuthenticationConverter():  <%= reactive ? 'Reactive' : '' %>JwtAuthenticationConverter {
        val grantedAuthoritiesConverter = JwtGrantedAuthoritiesConverter()
        grantedAuthoritiesConverter.setAuthorityPrefix("")
        grantedAuthoritiesConverter.setAuthoritiesClaimName(AUTHORITIES_KEY)

        val jwtAuthenticationConverter = <%= reactive ? 'Reactive' : '' %>JwtAuthenticationConverter()
<%_ if (reactive) { %>
        jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(ReactiveJwtGrantedAuthoritiesConverterAdapter(grantedAuthoritiesConverter))
<%_ } else { _%>
        jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(grantedAuthoritiesConverter)
<%_ } _%>
        return jwtAuthenticationConverter
    }

<%_ if (communicationSpringWebsocket) { %>
    @Bean
    fun bearerTokenResolver(): BearerTokenResolver{
        val bearerTokenResolver = new DefaultBearerTokenResolver()
        bearerTokenResolver.setAllowUriQueryParameter(true)
        return bearerTokenResolver
    }

<%_ } _%>
    private fun getSecretKey(): SecretKey {
        val keyBytes = Base64.from(jwtKey).decode()
        return SecretKeySpec(keyBytes, 0, keyBytes.length, JWT_ALGORITHM.name)
    }
}
